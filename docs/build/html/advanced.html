
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Doc détaillée &#8212; Documentation aboard 0.1.0</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <link rel="prev" title="aboard" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="doc-detaillee">
<h1>Doc détaillée<a class="headerlink" href="#doc-detaillee" title="Lien permanent vers ce titre">¶</a></h1>
<div class="section" id="objets-de-base-lecture-ecriture-simple">
<h2>Objets de base, lecture/écriture simple<a class="headerlink" href="#objets-de-base-lecture-ecriture-simple" title="Lien permanent vers ce titre">¶</a></h2>
<p>Un Board est un tableau à deux dimensions contenant des objets Tile.</p>
<p>La taille (largeur, hauteur) est à spécifier à la création.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">aboard</span> <span class="k">import</span> <span class="n">Board</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">board</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li>coordonnées (0, 0) : Tile en haut à gauche,</li>
<li>coordonnées (1, 0) : Tile juste à droite,</li>
<li>etc.</li>
<li>coordonnées (largeur-1, hauteur-1) : dernière Tile tout en bas à droite.</li>
</ul>
</div></blockquote>
<p>Une Tile possède les attributs suivants :</p>
<blockquote>
<div><ul class="simple">
<li>board_father : référence vers l’objet Board contenant la Tile.</li>
<li>x, y : position de la Tile dans le Board conteneur.</li>
<li>data : string. Donnée quelconque. Initialisée au caractère «&nbsp;.&nbsp;» (un point).</li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">board_father</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> et <code class="docutils literal notranslate"><span class="pre">y</span></code> peuvent être lus, mais ne devraient jamais être directement modifiés.</p>
<p><code class="docutils literal notranslate"><span class="pre">data</span></code> peut être lu et modifié.</p>
<p>Pour accéder à une Tile dans un Board, utilisez l’opérateur «&nbsp;[]&nbsp;» (<code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>), en spécifiant les coordonnées x et y.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tile</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="go">.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;ABCD&quot;</span>
</pre></div>
</div>
<p>L’opérateur «&nbsp;[]&nbsp;» accepte également les tuples <code class="docutils literal notranslate"><span class="pre">board[(3,</span> <span class="pre">2)]</span></code>, ainsi que les objets <code class="docutils literal notranslate"><span class="pre">Pos</span></code>. (Voir plus loin).</p>
<p>La fonction <cite>Board.render()</cite> renvoie une string multi-ligne (séparateur : «&nbsp;\n&nbsp;»), représentant le Board.</p>
<p>Dans la configuration de rendering par défaut, chaque Tile est représentée par un seul caractère, égal au premier caractère de l’attribut data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">.......</span>
<span class="go">.......</span>
<span class="go">...A...</span>
<span class="go">.......</span>
</pre></div>
</div>
</div>
<div class="section" id="iterateurs">
<h2>Itérateurs<a class="headerlink" href="#iterateurs" title="Lien permanent vers ce titre">¶</a></h2>
<div class="section" id="iterateurs-par-rectangle">
<h3>Itérateurs par rectangle<a class="headerlink" href="#iterateurs-par-rectangle" title="Lien permanent vers ce titre">¶</a></h3>
<p>Avec l’opérateur «&nbsp;[]&nbsp;», remplacez l’une ou les deux coordonnées par un slice, pour faire une itération sur une ligne, une colonne, un sous-rectangle, avec une ligne sur deux, de gauche à droite, …</p>
<p>Exemple :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">board</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">board</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;#&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">......</span>
<span class="go">.###..</span>
<span class="go">......</span>
<span class="go">......</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">4</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">2</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">index</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">......</span>
<span class="go">98765.</span>
<span class="go">......</span>
<span class="go">43210.</span>
</pre></div>
</div>
<p>Pour itérer en premier sur les colonnes, puis sur les lignes, ajouter le caractère «&nbsp;y&nbsp;» en troisième paramètre.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">board</span><span class="p">[:,</span> <span class="p">:,</span> <span class="s1">&#39;y&#39;</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">index</span> <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="k">else</span> <span class="s2">&quot;.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">048...</span>
<span class="go">159...</span>
<span class="go">26....</span>
<span class="go">37....</span>
</pre></div>
</div>
<p>Les slices renvoient un itérable, mais pas un indexable. On ne peut donc pas accéder directement à un élément en particulier. Mais on peut dérouler l’itérable dans une liste ou un tuple.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">board</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">&lt;positions_iterator.BoardIteratorRect object at 0x00BA6590&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
<span class="go">[&lt;Tile (2, 0): 8&gt;, &lt;Tile (2, 1): 9&gt;, &lt;Tile (2, 2): .&gt;, &lt;Tile (2, 3): .&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="iterateurs-par-liste-de-positions">
<h3>Itérateurs par liste de positions<a class="headerlink" href="#iterateurs-par-liste-de-positions" title="Lien permanent vers ce titre">¶</a></h3>
<p>Pour récupérer plusieurs Tiles à partir de positions arbitraires, il suffit d’itérer à partir d’une liste de coordonnées : <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">coord</span> <span class="pre">in</span> <span class="pre">[(0,</span> <span class="pre">0),</span> <span class="pre">(2,</span> <span class="pre">0),</span> <span class="pre">(3,</span> <span class="pre">1)]:</span> <span class="pre">current_tile</span> <span class="pre">=</span> <span class="pre">board[coord]</span></code>.</p>
<p>La fonction <code class="docutils literal notranslate"><span class="pre">Board.iter_positions</span></code> permet la même chose, mais en itérant directement sur les Tiles. Voir chapitre suivant pour un exemple.</p>
</div>
<div class="section" id="indicateurs-d-iterations">
<h3>Indicateurs d’itérations<a class="headerlink" href="#indicateurs-d-iterations" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les itérateurs de board possèdent des indicateurs mis à jour automatiquement :</p>
<blockquote>
<div><ul class="simple">
<li>prev_pos : position précédente (vaut None à la première itération).</li>
<li>jumped : vaut True si la position précédente et la position courante ne sont pas adjacentes.</li>
<li>changed_direction : vaut True si la direction de déplacement a changé lors de l’itération qui vient d’être effectuée.</li>
<li>both_coord_changed : vaut True si les deux coordonnées x et y de la position précédente et de la position courante sont différentes.</li>
</ul>
</div></blockquote>
<p>Pour les itérateurs par rectangle, l’indicateur <code class="docutils literal notranslate"><span class="pre">both_coord_changed</span></code> permet de savoir si on vient de changer de ligne.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iter_board</span> <span class="o">=</span> <span class="n">board</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">iter_board</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pos:&quot;</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;newline: &quot;</span><span class="p">,</span> <span class="n">iter_board</span><span class="o">.</span><span class="n">both_coord_changed</span><span class="p">)</span>
<span class="go">pos: 0 0 newline:  True</span>
<span class="go">pos: 1 0 newline:  False</span>
<span class="go">pos: 2 0 newline:  False</span>
<span class="go">pos: 0 1 newline:  True</span>
<span class="go">pos: 1 1 newline:  False</span>
<span class="go">pos: 2 1 newline:  False</span>
<span class="go">pos: 0 2 newline:  True</span>
<span class="go">pos: 1 2 newline:  False</span>
<span class="go">pos: 2 2 newline:  False</span>
<span class="go">pos: 0 3 newline:  True</span>
<span class="go">pos: 1 3 newline:  False</span>
<span class="go">pos: 2 3 newline:  False</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">positions</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iter_pos</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="n">iter_positions</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">iter_pos</span><span class="p">:</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span>
<span class="gp">... </span>       <span class="s2">&quot;pos:&quot;</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s2">&quot;prev:&quot;</span><span class="p">,</span> <span class="n">iter_pos</span><span class="o">.</span><span class="n">prev_pos</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s2">&quot;indics:&quot;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s2">&quot;jumped&quot;</span> <span class="o">*</span> <span class="n">iter_pos</span><span class="o">.</span><span class="n">jumped</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s2">&quot;changed_dir&quot;</span> <span class="o">*</span> <span class="n">iter_pos</span><span class="o">.</span><span class="n">changed_direction</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s2">&quot;both_changed&quot;</span> <span class="o">*</span> <span class="n">iter_pos</span><span class="o">.</span><span class="n">both_coord_changed</span>
<span class="gp">... </span>   <span class="p">)</span>
<span class="go">pos: &lt;Pos 0, 0 &gt; prev: None        indics: jumped  both_changed</span>
<span class="go">pos: &lt;Pos 1, 0 &gt; prev: &lt;Pos 0, 0 &gt; indics:</span>
<span class="go">pos: &lt;Pos 2, 0 &gt; prev: &lt;Pos 1, 0 &gt; indics:</span>
<span class="go">pos: &lt;Pos 4, 0 &gt; prev: &lt;Pos 2, 0 &gt; indics: jumped</span>
<span class="go">pos: &lt;Pos 4, 1 &gt; prev: &lt;Pos 4, 0 &gt; indics:  changed_dir</span>
<span class="go">pos: &lt;Pos 3, 3 &gt; prev: &lt;Pos 4, 1 &gt; indics: jumped changed_dir both_changed</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sur-iterators">
<h2>Sur_iterators<a class="headerlink" href="#sur-iterators" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les sur-itérateurs s’ajoutent après un itérateur de board.</p>
<div class="section" id="tell-indicators">
<h3><code class="docutils literal notranslate"><span class="pre">tell_indicators</span></code><a class="headerlink" href="#tell-indicators" title="Lien permanent vers ce titre">¶</a></h3>
<p>Il permet de renvoyer directement des indicateurs, durant l’itération.</p>
<p>Les types d’indicateurs renvoyés doivent être spécifiés via des valeurs <code class="docutils literal notranslate"><span class="pre">ItInd.*</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">aboard</span> <span class="k">import</span> <span class="n">ItInd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indics</span> <span class="o">=</span> <span class="p">(</span><span class="n">ItInd</span><span class="o">.</span><span class="n">PREV_POS</span><span class="p">,</span> <span class="n">ItInd</span><span class="o">.</span><span class="n">JUMPED</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">prev_pos</span><span class="p">,</span> <span class="n">jumped</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">board</span><span class="o">.</span><span class="n">iter_positions</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span><span class="o">.</span><span class="n">tell_indicators</span><span class="p">(</span><span class="n">indics</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span>
<span class="gp">... </span>       <span class="s2">&quot;pos:&quot;</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s2">&quot;prev:&quot;</span><span class="p">,</span> <span class="n">prev_pos</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s2">&quot;jumped:&quot;</span><span class="p">,</span> <span class="n">jumped</span><span class="p">,</span>
<span class="gp">... </span>   <span class="p">)</span>
<span class="go">pos: &lt;Pos 0, 0 &gt; prev: None        jumped: True</span>
<span class="go">pos: &lt;Pos 1, 0 &gt; prev: &lt;Pos 0, 0 &gt; jumped: False</span>
<span class="go">pos: &lt;Pos 2, 0 &gt; prev: &lt;Pos 1, 0 &gt; jumped: False</span>
<span class="go">pos: &lt;Pos 4, 0 &gt; prev: &lt;Pos 2, 0 &gt; jumped: True</span>
<span class="go">pos: &lt;Pos 4, 1 &gt; prev: &lt;Pos 4, 0 &gt; jumped: False</span>
<span class="go">pos: &lt;Pos 3, 3 &gt; prev: &lt;Pos 4, 1 &gt; jumped: True</span>
</pre></div>
</div>
</div>
<div class="section" id="group-by">
<h3><code class="docutils literal notranslate"><span class="pre">group_by</span></code><a class="headerlink" href="#group-by" title="Lien permanent vers ce titre">¶</a></h3>
<p>Il permet de renvoyer les tiles par groupe, selon une fonction de groupement, à indiquer en paramètre.</p>
<p>La fonction a pour paramètre l’itérateur, elle doit renvoyer un booléen. Chaque fois qu’elle renvoie True, le sur-itérateur renvoie le groupe de tile accumulées.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grouping_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">iterator</span><span class="p">:</span> <span class="p">(</span><span class="n">iterator</span><span class="o">.</span><span class="n">current_pos</span><span class="o">.</span><span class="n">x</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile_group</span> <span class="ow">in</span> <span class="n">board</span><span class="p">[:]</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">grouping_function</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">([(</span><span class="n">tile</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tile_group</span><span class="p">])</span>
<span class="go">[(0, 0), (1, 0), (2, 0)]</span>
<span class="go">[(3, 0), (4, 0), (5, 0)]</span>
<span class="go">[(0, 1), (1, 1), (2, 1)]</span>
<span class="go">[(3, 1), (4, 1), (5, 1)]</span>
<span class="go">[(0, 2), (1, 2), (2, 2)]</span>
<span class="go">[(3, 2), (4, 2), (5, 2)]</span>
<span class="go">[(0, 3), (1, 3), (2, 3)]</span>
<span class="go">[(3, 3), (4, 3), (5, 3)]</span>
</pre></div>
</div>
</div>
<div class="section" id="group-by-subcoord">
<h3><code class="docutils literal notranslate"><span class="pre">group_by_subcoord</span></code><a class="headerlink" href="#group-by-subcoord" title="Lien permanent vers ce titre">¶</a></h3>
<p>Sur-itérateur de type <code class="docutils literal notranslate"><span class="pre">group_by`</span></code>, dont la fonction de groupement se base sur <code class="docutils literal notranslate"><span class="pre">both_coord_changed</span></code>. Il permet de récupérer les tiles par groupe de lignes ou de colonnes, à partir d’un itérateur par rectangle.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile_group_column</span> <span class="ow">in</span> <span class="n">board</span><span class="p">[:,</span> <span class="p">:,</span> <span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">group_by_subcoord</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">tile_group_column</span><span class="p">)</span>
<span class="go">[&lt;Tile (0, 0): 0&gt;, &lt;Tile (0, 1): 1&gt;, &lt;Tile (0, 2): 2&gt;, &lt;Tile (0, 3): 3&gt;]</span>
<span class="go">[&lt;Tile (1, 0): 4&gt;, &lt;Tile (1, 1): 5&gt;, &lt;Tile (1, 2): 6&gt;, &lt;Tile (1, 3): 7&gt;]</span>
<span class="go">[&lt;Tile (2, 0): 8&gt;, &lt;Tile (2, 1): 9&gt;, &lt;Tile (2, 2): .&gt;, &lt;Tile (2, 3): .&gt;]</span>
<span class="go">[&lt;Tile (3, 0): .&gt;, &lt;Tile (3, 1): .&gt;, &lt;Tile (3, 2): .&gt;, &lt;Tile (3, 3): .&gt;]</span>
<span class="go">[&lt;Tile (4, 0): .&gt;, &lt;Tile (4, 1): .&gt;, &lt;Tile (4, 2): .&gt;, &lt;Tile (4, 3): .&gt;]</span>
<span class="go">[&lt;Tile (5, 0): .&gt;, &lt;Tile (5, 1): .&gt;, &lt;Tile (5, 2): .&gt;, &lt;Tile (5, 3): .&gt;]</span>
</pre></div>
</div>
<p>Il n’est pas possible d’enchaîner les sur-itérateurs. <code class="docutils literal notranslate"><span class="pre">board[:].tell_indicators(x).group_by(y)</span></code> ne fonctionne pas.</p>
</div>
</div>
<div class="section" id="heritage-de-la-classe-tile">
<h2>Héritage de la classe Tile<a class="headerlink" href="#heritage-de-la-classe-tile" title="Lien permanent vers ce titre">¶</a></h2>
<p>Il est possible de créer des classes héritées de la classe Tile, et de s’en servir pour créer un board.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">aboard</span> <span class="k">import</span> <span class="n">Tile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyTile</span><span class="p">(</span><span class="n">Tile</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">board_with_my_tiles</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">class_tile</span><span class="o">=</span><span class="n">MyTile</span><span class="p">)</span>
</pre></div>
</div>
<p>Les classes héritées peuvent utiliser d’autres attributs de données, en plus de tile.data.</p>
<p>Il est conseillé d’overrider les fonctions <code class="docutils literal notranslate"><span class="pre">__str__</span></code> et <code class="docutils literal notranslate"><span class="pre">__repr__</span></code>. Les versions de base affichent uniquement tile.data.</p>
<p>La fonction <code class="docutils literal notranslate"><span class="pre">__eq__</span></code> peut être overridée. Elle devrait l’être si on utilise la classe <code class="docutils literal notranslate"><span class="pre">IteratorGetDifferences</span></code> (qui n’est pas encore documentée ici).</p>
<p>La fonction <code class="docutils literal notranslate"><span class="pre">__eq__</span></code> est supposée comparer uniquement les données à l’intérieur de la Tile, et non pas sa position (Tile.data, et non pas Tile.pos).</p>
<div class="section" id="fonction-tile-render">
<h3>Fonction <code class="docutils literal notranslate"><span class="pre">Tile.render</span></code><a class="headerlink" href="#fonction-tile-render" title="Lien permanent vers ce titre">¶</a></h3>
<p>Cette fonction peut être overridée. Elle est censée renvoyer une string ou une liste de string, qui est ensuite transmise à la fonction <code class="docutils literal notranslate"><span class="pre">board.render</span></code>.</p>
<p>Par défaut, chaque tile est rendue sur un seul caractère. Même si <code class="docutils literal notranslate"><span class="pre">Tile.render</span></code> en renvoie plus, seul le premier sera utilisé. Il est possible de configurer un renderer pour le faire afficher des tiles sur des rectangles de caractères (voir plus loin).</p>
<p>Lorsque la fonction <code class="docutils literal notranslate"><span class="pre">tile.render</span></code> est appelée, deux paramètres <code class="docutils literal notranslate"><span class="pre">w</span></code> et <code class="docutils literal notranslate"><span class="pre">h</span></code> lui sont indiqués, représentant la taille du rectangle de rendu. La fonction est alors censée renvoyer une liste de <code class="docutils literal notranslate"><span class="pre">h</span></code> éléments, chacun d’eux devant être une string de <code class="docutils literal notranslate"><span class="pre">w</span></code> caractères.</p>
<p>Si ce n’est pas exactement cette structure de données qui est renvoyée, le renderer la remet en forme. Il coupe des éléments de la liste et des caractères, et ajoute des espaces, de façon à avoir un rectangle de rendu correct.</p>
</div>
</div>
<div class="section" id="objet-boardrenderer">
<h2>Objet BoardRenderer<a class="headerlink" href="#objet-boardrenderer" title="Lien permanent vers ce titre">¶</a></h2>
<div class="section" id="utilisation">
<h3>Utilisation<a class="headerlink" href="#utilisation" title="Lien permanent vers ce titre">¶</a></h3>
<p>Il s’agit d’un objet utilisant les données d’un Board, pour générer la string de rendu.</p>
<p>Tous les objets Board possèdent en variable membre un objet BoardRenderer par défaut, qui est utilisé lors de l’appel à <code class="docutils literal notranslate"><span class="pre">Board.render()</span></code>.</p>
<p>Il est possible de créer un autre BoardRenderer doté d’une configuration spécifique, et de les utiliser pour générer des strings de rendu différentes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">aboard</span> <span class="k">import</span> <span class="n">BoardRenderer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">board</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">board</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;ABZZ&quot;</span><span class="p">,</span> <span class="s2">&quot;CDZZ&quot;</span><span class="p">,</span> <span class="s2">&quot;XXZZ&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_renderer</span> <span class="o">=</span> <span class="n">BoardRenderer</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">tile_w</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tile_h</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chr_fill_tile</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">tile_padding_w</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tile_padding_h</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">renderer</span><span class="o">=</span><span class="n">my_renderer</span><span class="p">))</span>
<span class="go">._ ._ ._ ._</span>
<span class="go">__ __ __ __</span>
<span class="go">._ AB ._ ._</span>
<span class="go">__ CD __ __</span>
<span class="go">._ ._ ._ ._</span>
<span class="go">__ __ __ __</span>
</pre></div>
</div>
<p>Il est également possible de définir le renderer dès l’instanciation du board.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_renderer</span> <span class="o">=</span> <span class="n">BoardRenderer</span><span class="p">(</span><span class="n">tile_w</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tile_h</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">board</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">default_renderer</span><span class="o">=</span><span class="n">my_renderer</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="parametres-du-renderer">
<h3>Paramètres du renderer<a class="headerlink" href="#parametres-du-renderer" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les paramètres sont à indiquer lors de l’instanciation du BoardRenderer. Ils ont tous une valeur par défaut, correspondant à celle du renderer par défaut inclus dans chaque Board.</p>
<blockquote>
<div><ul class="simple">
<li>tile_w, tile_h : largeur et hauteur des tiles</li>
<li>chr_fill_tile : caractère utilisé pour compléter les rectangles des Tiles, lorsque la fonction <code class="docutils literal notranslate"><span class="pre">Tile.render</span></code> ne renvoie pas suffisamment de caractères.</li>
<li>tile_padding_w, tile_padding_h : nombre de caractère d’espacement entre chaque Tile, horizontal et vertical. Par défaut : 0.</li>
<li>chr_fill_tile_padding : caractère utilisé pour écrire les paddings horizontaux et verticaux. Par défaut : “ “ (espace).</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="regle-d-adjacence">
<h2>Règle d’adjacence<a class="headerlink" href="#regle-d-adjacence" title="Lien permanent vers ce titre">¶</a></h2>
<p>La règle d’adjacence a pour but d’indiquer, pour deux Tiles d’un même Board, si elles sont adjacentes ou non.</p>
<p>Elle est utilisée dans les fonctions de pathfinding, de remplissage par propagation et pour les indicateurs d’itération (indicateur «&nbsp;jumped&nbsp;»).</p>
<div class="section" id="selection-de-la-regle">
<h3>Sélection de la règle<a class="headerlink" href="#selection-de-la-regle" title="Lien permanent vers ce titre">¶</a></h3>
<p>Un board possède dans ses variables membres une instance d’une classe <code class="docutils literal notranslate"><span class="pre">AdjacencyEvaluator</span></code>, définissant sa règle d’adjacence. Par défaut, un board utilise <code class="docutils literal notranslate"><span class="pre">AdjacencyEvaluatorCross</span></code>, qui considère que deux tiles sont adjacentes si elles sont côte à côte, sur la même ligne ou la même colonne, mais pas en diagonale.</p>
<p>Pour utiliser une autre règle d’adjacence, il faut la spécifier lors de la création du board.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">adjacency</span> <span class="k">import</span> <span class="n">AdjacencyEvaluatorCrossDiag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">board_adj_diag</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">class_adjacency</span><span class="o">=</span><span class="n">AdjacencyEvaluatorCrossDiag</span><span class="p">)</span>
</pre></div>
</div>
<p>La classe <code class="docutils literal notranslate"><span class="pre">AdjacencyEvaluatorCrossDiag</span></code> considère que deux tiles sont adjacente si elles sont côte à côte ou en diagonale.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">get_by_pathfinding</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
<span class="go">[&#39;&lt;Tile (0, 1): .&gt;&#39;, &#39;&lt;Tile (1, 1): .&gt;&#39;, &#39;&lt;Tile (1, 2): .&gt;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">board_adj_diag</span><span class="o">.</span><span class="n">get_by_pathfinding</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
<span class="go">[&#39;&lt;Tile (0, 1): .&gt;&#39;, &#39;&lt;Tile (1, 2): .&gt;&#39;]</span>
</pre></div>
</div>
<p>Il est également possible de redéfinir l’adjacence par défaut, qui sera utilisée lors de la création de tous les prochains Boards.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">aboard</span> <span class="k">import</span> <span class="n">set_default_adjacency</span><span class="p">,</span> <span class="n">AdjacencyEvaluatorCrossDiag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_default_adjacency</span><span class="p">(</span><span class="n">AdjacencyEvaluatorCrossDiag</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="creation-d-une-regle-d-adjacence-customisee">
<h3>Création d’une règle d’adjacence customisée<a class="headerlink" href="#creation-d-une-regle-d-adjacence-customisee" title="Lien permanent vers ce titre">¶</a></h3>
<p>Pour créer une autre règle d’adjacence, il faut hériter la classe <code class="docutils literal notranslate"><span class="pre">AdjacencyEvaluator</span></code>, et surcharger deux de ses fonctions :</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">is_adjacent(self,</span> <span class="pre">pos_1,</span> <span class="pre">pos_2)</span></code> : renvoie un booléen, indiquant si les deux positions passées en paramètre sont adjacentes.</li>
<li><code class="docutils literal notranslate"><span class="pre">adjacent_positions(self,</span> <span class="pre">pos):</span></code> : renvoie un itérateur qui liste toutes les positions adjacentes à celle passée en paramètre.</li>
</ul>
</div></blockquote>
<p>La classe héritée possède un paramètre <code class="docutils literal notranslate"><span class="pre">board</span></code>, correspondant au Board d’appartenance, sur lequel la règle d’adjacence doit s’appliquer.</p>
<p>Exemple de création d’une règle d’adjacence «&nbsp;torique&nbsp;». Cette règle considère que le Board est un tore. Lorsqu’on se déplace sur un bord, on est téléporté de l’autre côté. Les tiles tout à droite sont adjacentes avec celles tout à gauche, et les tiles tout en bas sont adjacentes avec celles tout en haut.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">aboard</span> <span class="k">import</span> <span class="n">Pos</span><span class="p">,</span> <span class="n">AdjacencyEvaluator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">AdjacencyEvaluatorCrossTore</span><span class="p">(</span><span class="n">AdjacencyEvaluator</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">is_adjacent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos_1</span><span class="p">,</span> <span class="n">pos_2</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">pos_1</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">pos_2</span><span class="o">.</span><span class="n">x</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="p">(</span><span class="n">pos_1</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">h</span> <span class="o">==</span> <span class="n">pos_2</span><span class="o">.</span><span class="n">y</span><span class="p">:</span><span class="k">return</span> <span class="kc">True</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="p">(</span><span class="n">pos_2</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">h</span> <span class="o">==</span> <span class="n">pos_1</span><span class="o">.</span><span class="n">y</span><span class="p">:</span><span class="k">return</span> <span class="kc">True</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">pos_1</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">pos_2</span><span class="o">.</span><span class="n">y</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="p">(</span><span class="n">pos_1</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">w</span> <span class="o">==</span> <span class="n">pos_2</span><span class="o">.</span><span class="n">x</span><span class="p">:</span><span class="k">return</span> <span class="kc">True</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="p">(</span><span class="n">pos_2</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">w</span> <span class="o">==</span> <span class="n">pos_1</span><span class="o">.</span><span class="n">x</span><span class="p">:</span><span class="k">return</span> <span class="kc">True</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">adjacent_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">]</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">offset_x</span><span class="p">,</span> <span class="n">offset_y</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">offset_x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">w</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">w</span>
<span class="gp">... </span>            <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">offset_y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">h</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">h</span>
<span class="gp">... </span>            <span class="k">yield</span> <span class="n">Pos</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">board_adj_tore</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">class_adjacency</span><span class="o">=</span><span class="n">AdjacencyEvaluatorCrossTore</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">board_adj_tore</span><span class="o">.</span><span class="n">get_by_pathfinding</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board_adj_tore</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">...........</span>
<span class="go">XXX......XX</span>
<span class="go">...........</span>
</pre></div>
</div>
<p>Avec cette règle, le chemin le plus court pour aller de (2, 1) à (9, 1) n’est pas un déplacement vers la droite, mais vers la gauche. On est téléporté du côté gauche vers le côté droit.</p>
</div>
</div>
<div class="section" id="fonction-de-remplissage-par-propagation">
<h2>Fonction de remplissage par propagation<a class="headerlink" href="#fonction-de-remplissage-par-propagation" title="Lien permanent vers ce titre">¶</a></h2>
<p>La fonction <code class="docutils literal notranslate"><span class="pre">Board.get_by_propagation</span></code> effectue une itération à partir d’une tile initiale, et se propage petit à petit vers les tiles adjacentes remplissant la «&nbsp;condition de propagation&nbsp;». Par défaut, cette condition est vraie si la <code class="docutils literal notranslate"><span class="pre">data</span></code> de la tile vers laquelle on se propage vaut le caractère “.”. Il est possible de la redéfinir via le paramètre <code class="docutils literal notranslate"><span class="pre">propag_condition</span></code>.</p>
<p>Il s’agit d’une fonction ayant deux paramètres : <code class="docutils literal notranslate"><span class="pre">tile_source</span></code> (la tile de départ actuelle), <code class="docutils literal notranslate"><span class="pre">tile_dest</span></code> (la tile vers laquelle on tente de se propager). Cette fonction doit renvoyer un booléen, indiquant si la propagation est possible ou non.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">to_right_and_last_column</span><span class="p">(</span><span class="n">tile_source</span><span class="p">,</span> <span class="n">tile_dest</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">tile_dest</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">tile_source</span><span class="o">.</span><span class="n">x</span><span class="p">:</span><span class="k">return</span> <span class="kc">True</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">tile_dest</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">tile_dest</span><span class="o">.</span><span class="n">board_owner</span><span class="o">.</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="k">return</span> <span class="kc">True</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">aboard</span> <span class="k">import</span> <span class="n">AdjacencyEvaluatorCross</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_default_adjacency</span><span class="p">(</span><span class="n">AdjacencyEvaluatorCross</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">board</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">board</span><span class="o">.</span><span class="n">get_by_propagation</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">to_right_and_last_column</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">.....X</span>
<span class="go">.....X</span>
<span class="go">.XXXXX</span>
<span class="go">.....X</span>
<span class="go">.....X</span>
</pre></div>
</div>
<p>La propagation utilise la règle d’adjacence par défaut du board. L’ordre d’itération dépend de l’ordre des tiles renvoyées par la fonction <code class="docutils literal notranslate"><span class="pre">adjacent_positions</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">board</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">board</span><span class="o">.</span><span class="n">get_by_propagation</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">to_right_and_last_column</span><span class="p">)</span>
<span class="gp">... </span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">index</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">.....7</span>
<span class="go">.....5</span>
<span class="go">.01234</span>
<span class="go">.....6</span>
<span class="go">.....8</span>
</pre></div>
</div>
<p>Le changement de règle d’adjacence peut avoir des conséquences sur la propagation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">board</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">class_adjacency</span><span class="o">=</span><span class="n">AdjacencyEvaluatorCrossDiag</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">board</span><span class="o">.</span><span class="n">get_by_propagation</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">to_right_and_last_column</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">...XXX</span>
<span class="go">..XXXX</span>
<span class="go">.XXXXX</span>
<span class="go">..XXXX</span>
<span class="go">...XXX</span>
</pre></div>
</div>
<p>L’itérateur par propagation possède un indicateur spécifique : <code class="docutils literal notranslate"><span class="pre">PROPAG_DIST</span></code>, indiquant la distance parcourue depuis la tile initiale jusqu’à la case courante.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">board</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">board_it</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="n">get_by_propagation</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">to_right_and_last_column</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">dist</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">board_it</span><span class="o">.</span><span class="n">tell_indicators</span><span class="p">((</span><span class="n">ItInd</span><span class="o">.</span><span class="n">PROPAG_DIST</span><span class="p">,</span> <span class="p">)):</span>
<span class="gp">... </span>    <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">dist</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">.....6</span>
<span class="go">.....5</span>
<span class="go">.01234</span>
<span class="go">.....5</span>
<span class="go">.....6</span>
</pre></div>
</div>
</div>
<div class="section" id="path-finding">
<h2>Path-finding<a class="headerlink" href="#path-finding" title="Lien permanent vers ce titre">¶</a></h2>
<p>La fonction <code class="docutils literal notranslate"><span class="pre">Board.get_by_pathfinding</span></code> recherche un chemin le plus court entre deux positions, et effectue une itération dessus, à partir de la tile de départ vers la tile d’arrivée.</p>
<p>Cette fonction utilise une «&nbsp;condition de déplacement&nbsp;», similaire à la condition de propagation. Par défaut, le déplacement est possible si la <code class="docutils literal notranslate"><span class="pre">data</span></code> de la tile vers laquelle on se propage vaut le caractère “.”. Il est possible de la redéfinir via le paramètre <code class="docutils literal notranslate"><span class="pre">pass_through_condition</span></code>.</p>
<p>Le path-finding utilise les règles d’adjacence par défaut du board. Lorsqu’il existe plusieurs possibilités de chemin le plus court, la fonction en sélectionne un seul. Cette sélection dépend de l’ordre des tiles renvoyées par la fonction <code class="docutils literal notranslate"><span class="pre">adjacent_positions</span></code>.</p>
<p>La fonction <code class="docutils literal notranslate"><span class="pre">pass_through_condition</span></code> fonctionne de la même manière que <code class="docutils literal notranslate"><span class="pre">propag_condition</span></code>. Elle possède deux paramètres : <code class="docutils literal notranslate"><span class="pre">tile_source</span></code> (la tile de départ actuelle), <code class="docutils literal notranslate"><span class="pre">tile_dest</span></code> (la tile vers laquelle on tente de se déplacer), et doit renvoyer un booléen, indiquant si le déplacement est possible ou non.</p>
<p>Le path-finding déclenche une exception <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> si il n’existe aucun chemin possible.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">board</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">board</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">board</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">board</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">board</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">.........</span>
<span class="go">.........</span>
<span class="go">..#####..</span>
<span class="go">..#...&gt;..</span>
<span class="go">..#...&gt;..</span>
<span class="go">..#####..</span>
<span class="go">.........</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">board</span><span class="o">.</span><span class="n">get_by_pathfinding</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">!=</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span> <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/path/to/git/aboard/code/propagation_iterator.py&quot;</span>, line <span class="m">121</span>, in <span class="n">__iter__</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Impossible de trouver un chemin&quot;</span><span class="p">)</span>
<span class="gr">ValueError</span>: <span class="n">Impossible de trouver un chemin</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_pass_through_condition</span><span class="p">(</span><span class="n">tile_source</span><span class="p">,</span> <span class="n">tile_dest</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">tile_datas</span> <span class="o">=</span> <span class="p">(</span><span class="n">tile_source</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">tile_dest</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">tile_datas</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="kc">True</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">tile_datas</span> <span class="ow">in</span> <span class="p">((</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">)):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">tile_source</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">tile_dest</span><span class="o">.</span><span class="n">x</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="kc">False</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">board</span><span class="o">.</span><span class="n">get_by_pathfinding</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">my_pass_through_condition</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">!=</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">********.</span>
<span class="go">.......*.</span>
<span class="go">..#####*.</span>
<span class="go">..#...&gt;*.</span>
<span class="go">..#***&gt;*.</span>
<span class="go">..#####..</span>
<span class="go">.........</span>
</pre></div>
</div>
<p>Le chemin aurait été un peu différent avec une règle d’adjacence autorisant les diagonales.</p>
</div>
<div class="section" id="echanges-et-permutations-circulaires-de-tiles">
<h2>Échanges et permutations circulaires de tiles<a class="headerlink" href="#echanges-et-permutations-circulaires-de-tiles" title="Lien permanent vers ce titre">¶</a></h2>
<p>Chaque case d’un Board ne doit contenir rien d’autre qu’une Tile (pas de None, pas de liste de Tile, etc.). Les Tiles ne sont pas supposées se déplacer dans le Board. Pour représenter des éléments qui se déplacent d’une case à l’autre, il faut modifier la variable <code class="docutils literal notranslate"><span class="pre">tile.data</span></code>, ou utiliser des <code class="docutils literal notranslate"><span class="pre">MobileItems</span></code> (voir plus loin).</p>
<p>Cependant, comme cette fonctionnalité pourrait être utile, et que les <code class="docutils literal notranslate"><span class="pre">MobileItem</span></code> ne sont pas terminés, il est possible d’utiliser la fonction <code class="docutils literal notranslate"><span class="pre">board.replace_tile</span></code>. Celle-ci met à jour automatiquement les variables <code class="docutils literal notranslate"><span class="pre">tile.x</span></code> et <code class="docutils literal notranslate"><span class="pre">tile.y</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">board</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_t</span> <span class="o">=</span> <span class="n">Tile</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_t</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">new_t</span><span class="p">)</span>
<span class="go">&lt;Tile (None, None): A&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">board</span><span class="o">.</span><span class="n">replace_tile</span><span class="p">(</span><span class="n">new_t</span><span class="p">,</span> <span class="n">Pos</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">A..</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">new_t</span><span class="p">)</span>
<span class="go">&lt;Tile (0, 1): A&gt;</span>
</pre></div>
</div>
<p>Pour déplacer plusieurs tiles en une seule opération de permutation circulaire, utiliser la fonction <code class="docutils literal notranslate"><span class="pre">board.circular_permute_tiles</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">board</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">board</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="n">tile</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">index</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">positions</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Pos</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span> <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">board</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">board</span><span class="o">.</span><span class="n">circular_permute_tiles</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">......</span>
<span class="go">023415</span>
<span class="go">......</span>
</pre></div>
</div>
</div>
<div class="section" id="build-pour-codingame">
<h2>build pour codingame<a class="headerlink" href="#build-pour-codingame" title="Lien permanent vers ce titre">¶</a></h2>
<p>La librairie aboard est compilée en un seul fichier de code : <code class="docutils literal notranslate"><span class="pre">code/builder/aboard_standalone.py</span></code>. Ce fichier permet une utilisation de la librairie dans des contextes spécifiques. Par exemple, il est possible de copier-coller son contenu dans un puzzle ou un challenge du site codingame.com.</p>
<p>Le début du fichier stand-alone indique la version et le commit git qui ont été utilisés pour le générer.</p>
<p>Le script <code class="docutils literal notranslate"><span class="pre">code/builder/builder.py</span></code> permet de regénérer manuellement ce fichier à partir du code actuel.</p>
</div>
<div class="section" id="mobile-items-en-construction">
<h2>Mobile Items (en construction)<a class="headerlink" href="#mobile-items-en-construction" title="Lien permanent vers ce titre">¶</a></h2>
<p>Ça fonctionne mais ce n’est vraiment pas pratique et il n’y a pas beaucoup de fonctions pour les manipuler, les déplacer, etc.</p>
<p>Cette partie sera détaillé plus tard.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mobitem</span> <span class="k">import</span> <span class="n">MobileItem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">board</span> <span class="o">=</span> <span class="n">Board</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mobitem</span> <span class="o">=</span> <span class="n">MobileItem</span><span class="p">(</span><span class="n">tile_owner</span><span class="o">=</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">#.</span>
<span class="go">..</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mobitem</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mobitem</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">render</span><span class="p">())</span>
<span class="go">.M</span>
<span class="go">..</span>
</pre></div>
</div>
</div>
<div class="section" id="exemple-complet">
<h2>exemple complet<a class="headerlink" href="#exemple-complet" title="Lien permanent vers ce titre">¶</a></h2>
<p>Exemple inspiré du challenge codingame «&nbsp;Xmas Rush&nbsp;», lui-même inspiré du jeu de plateau «&nbsp;Labyrinthe&nbsp;».</p>
<p>Chaque Tile possède duex attributs spécifiques :</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">mid_marker</span></code> : une string (ou l’équivalent), dont seul le premier caractère est utilisé.</li>
<li><code class="docutils literal notranslate"><span class="pre">roads</span></code> : dictionnaire contenant 4 éléments, les clés étant les 4&nbsp;directions. La valeur de chaque clé est un booléen, indiquant si la tile possède une ouverture dans la direction donnée.</li>
</ul>
</div></blockquote>
<p>Une Tile est rendu sur un carré de 3*3 caractères, avec l’affichage des chemins, et le <code class="docutils literal notranslate"><span class="pre">mid_marker</span></code> écrit au milieu.</p>
<p>La règle d’adjacence est celle par défaut :&nbsp;les 4 directions, mais pas de diagonale.</p>
<p>L’initialisation du board est effectuée par un tableau de caractère, chacun d’eux permet de déduire le contenu du <code class="docutils literal notranslate"><span class="pre">roads</span></code> de la Tile concernée.</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a></p>
<p>from aboard import Board, Tile, Dir, BoardRenderer, compute_direction</p>
<p>class XmasTile(Tile):</p>
<blockquote>
<div><dl class="docutils">
<dt>DICT_ROADFUL_DIRS_FROM_CHAR = {</dt>
<dd>“-“: (Dir.LEFT, Dir.RIGHT),
“|”: (Dir.UP, Dir.DOWN),
“L”: (Dir.UP, Dir.RIGHT),
“F”: (Dir.DOWN, Dir.RIGHT),
“7”: (Dir.DOWN, Dir.LEFT),
“J”: (Dir.UP, Dir.LEFT),
“+”: (Dir.LEFT, Dir.RIGHT, Dir.UP, Dir.DOWN),
“ “: (),</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>def __init__(self, x=None, y=None, board_father=None):</dt>
<dd><p class="first">super().__init__(x, y, board_father)
self.roads = {</p>
<blockquote>
<div>Dir.UP: False,
Dir.RIGHT: False,
Dir.DOWN: False,
Dir.LEFT: False,</div></blockquote>
<p class="last">}
self.mid_marker = “ “</p>
</dd>
<dt>def dirs_from_input(self, char_roadful):</dt>
<dd><dl class="first last docutils">
<dt>for <a href="#id9"><span class="problematic" id="id10">dir_</span></a> in XmasTile.DICT_ROADFUL_DIRS_FROM_CHAR[char_roadful]:</dt>
<dd>self.roads[<a href="#id11"><span class="problematic" id="id12">dir_</span></a>] = True</dd>
</dl>
</dd>
</dl>
<p>def render(self, w=3, h=3):</p>
<blockquote>
<div><p>path_up = “|” if self.roads[Dir.UP] else “ “
path_left = “-“ if self.roads[Dir.LEFT] else “ “
path_right = “-“ if self.roads[Dir.RIGHT] else “ “
path_down = “|” if self.roads[Dir.DOWN] else “ “
template = &nbsp;» %s n%s%s%sn %s «&nbsp;</p>
<dl class="docutils">
<dt>data = (</dt>
<dd>path_up,
path_left,
self.mid_marker[:1].rjust(1),
path_right,
path_down,</dd>
</dl>
<p>)</p>
<p>str_result = template % data
# Will return something weird if self.mid_marker contains a newline.
# Not supposed to happen.
return str_result.split(“n”)</p>
</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>renderer = BoardRenderer(</dt>
<dd>tile_w=3, tile_h=3,
tile_padding_w=1, tile_padding_h=1, chr_fill_tile_padding=”.”)</dd>
<dt>board = Board(</dt>
<dd>6, 5, class_tile=XmasTile,
default_renderer=renderer,</dd>
</dl>
<p>)</p>
<dl class="docutils">
<dt>BOARD_MAP = «&nbsp;&nbsp;»«&nbsp;</dt>
<dd>F—7</dd>
</dl>
<p>F+7  |
||   |
L—-J
«&nbsp;&nbsp;»«&nbsp;</p>
<p>board_map = BOARD_MAP.replace(“n”, “”)</p>
<dl class="docutils">
<dt>for tile, char_roadful in zip(board, board_map):</dt>
<dd>tile.dirs_from_input(char_roadful)</dd>
<dt>def pass_through_xmas(tile_source, tile_dest):</dt>
<dd><p class="first"><a href="#id13"><span class="problematic" id="id14">dir_</span></a> = compute_direction(tile_source, tile_dest)
roads_to_check = {</p>
<blockquote>
<div>Dir.UP:(Dir.UP, Dir.DOWN),
Dir.DOWN:(Dir.DOWN, Dir.UP),
Dir.LEFT:(Dir.LEFT, Dir.RIGHT),
Dir.RIGHT:(Dir.RIGHT, Dir.LEFT),</div></blockquote>
<p>}
road_to_check = roads_to_check.get(<a href="#id15"><span class="problematic" id="id16">dir_</span></a>)
if road_to_check is None:</p>
<blockquote>
<div># Not supposed to happen
return False</div></blockquote>
<p class="last">road_source, road_dest = road_to_check
return tile_source.roads[road_source] and tile_dest.roads[road_dest]</p>
</dd>
<dt>for index, tile in enumerate(board.get_by_pathfinding((0, 3), (2, 0), pass_through_xmas)):</dt>
<dd>tile.mid_marker = str(index)</dd>
<dt>print(board.render())</dt>
<dd>.   .   .   .   .
. 4-.-5-.- -.- -.-
. | .   .   .   . |</dd>
</dl>
<blockquote>
<div><div class="line-block">
<div class="line">. | . | .   .   . |</div>
</div>
</div></blockquote>
<blockquote>
<div><div class="line-block">
<div class="line">. | .   .   .   . |</div>
</div>
</div></blockquote>
<blockquote>
<div>.   .   .   .   .</div></blockquote>
<blockquote>
<div>.   .   .   .   .</div></blockquote>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">aboard</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Doc détaillée</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#objets-de-base-lecture-ecriture-simple">Objets de base, lecture/écriture simple</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iterateurs">Itérateurs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sur-iterators">Sur_iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#heritage-de-la-classe-tile">Héritage de la classe Tile</a></li>
<li class="toctree-l2"><a class="reference internal" href="#objet-boardrenderer">Objet BoardRenderer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#regle-d-adjacence">Règle d’adjacence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fonction-de-remplissage-par-propagation">Fonction de remplissage par propagation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#path-finding">Path-finding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#echanges-et-permutations-circulaires-de-tiles">Échanges et permutations circulaires de tiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#build-pour-codingame">build pour codingame</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mobile-items-en-construction">Mobile Items (en construction)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exemple-complet">exemple complet</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="Chapitre précédent">aboard</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Recherche rapide</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Réchèr.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/advanced.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>