# TODO List / roadmap

Pour pouvoir m'y replonger plus facilement quand ce sera le moment.
 - pas besoin d'avoir des tell\_jumps, tell\_machin. On fait un sur-itérateur qui fait ça.
 - pareil pour les sliding\_windows et continuous\_sliding\_windows. On sur-itère. Et on pourra proposer ces sur-itérateurs dans une autre classe.
   pour les windows : https://stackoverflow.com/questions/6822725/rolling-or-sliding-window-iterator#6822773
 X Par contre, itérer sur les positions, et sur-itérer sur le board, c'est stupide. Tous les itérateurs ont un board dans leur variable membre. Arrêtons d'être stupide.
 X Tous les TODO de factorisation dans le RectIterator
 - Sur les itérateurs : ajouter une variable de flag : `both_coords_changed`. C'est ce flag qui permet à coup sûr de savoir qu'on est "allé à la ligne" avec un RectIterator. Mais le flag est valable pour tous les types d'itérateurs. (C'est fait, mais faut le tester entièrement).
 - adjacency est une classe. on instancie l'adjacency par défaut. chaque board a la sienne (mais ça peut être une référence vers toujours la même classe).
   adjacence "torique", avec une size globale : x = size.x-1 est adjacent à x = 0. adjacence torique avec diagonale.
 - Ranger le code. Tous les tests dans un répertoire. Tout le code dans un répertoire `aboard`. Un main à la racine, un test à la racine. (En espérant que ce soit faisable).
 - Test des variables de flags sur le RectIterator.
 X un Iterator générique, et ensuite un PositionIterator puis un RectIterator. Et faut trouver un nom à cet iter générique, ou bien trouver un autre nom à PositionIterator.
 - classe Board. Itérable avec un RectIterator simple. Itérable avec `board[1:20:3][::-1]` (le sens sera toujours le sens par défaut. FUTURE : on pourra le redéfinir)
 - les sliding windows, (éventuellement continuous sliding windows), et les tell_flags, dans l'itérateur générique.
 - classe Direction. Rajouter des noms dans `DICT_DIR_FROM_STR`. Mettre dans un fichier à part. Rendre la classe Direction ordonnable (up = 0, et ensuite dans le sens des aiguilles d'une montre). Itérateur de direction, avec ou sans diag.
 - tous les TODO qui restent dans le code.
 - itération par propagation. Avec une injection de dépendance (une fonction) qui indique si on peut propager ou pas. (à priori, faudra un iterator, puis un BoardIterator.)
 - finir le renderer.
 - pathfinding. Avec re une injection de dépendance. Pathfinding en mode shortest, ou tous les paths possible.
 - doc, processus d'obfuscation et rassemblement en un seul fichier, démo avec des entraînement de coding game, ...

